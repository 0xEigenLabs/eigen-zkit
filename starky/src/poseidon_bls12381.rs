#![allow(deprecated, dead_code)]
#![allow(clippy::derive_hash_xor_eq, clippy::too_many_arguments)]
use crate::constant::POSEIDON_BLS12381_CONSTANTS;
use crate::field_bls12381::Fr;
use crate::poseidon_bls12381_constants as constants;
use ff::*;

/// Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
/// Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
/// And rounded up to nearest integer that divides by t
#[derive(Debug)]
pub struct Constants {
    pub c: Vec<Vec<Fr>>,
    pub m: Vec<Vec<Vec<Fr>>>,
    pub p: Vec<Vec<Vec<Fr>>>,
    pub s: Vec<Vec<Fr>>,
    pub n_rounds_f: usize,
    pub n_rounds_p: Vec<usize>,
}

pub fn load_constants() -> Constants {
    let (c_str, m_str) = constants::constants();
    let mut c: Vec<Vec<Fr>> = Vec::new();
    for v1 in c_str {
        let mut cci: Vec<Fr> = Vec::new();
        for v2 in v1 {
            let b: Fr = from_hex(v2).unwrap();
            cci.push(b);
        }
        c.push(cci);
    }
    let mut m: Vec<Vec<Vec<Fr>>> = Vec::new();
    for v1 in m_str {
        let mut mi: Vec<Vec<Fr>> = Vec::new();
        for v2 in v1 {
            let mut mij: Vec<Fr> = Vec::new();
            for s in v2 {
                let b: Fr = from_hex(s).unwrap();
                mij.push(b);
            }
            mi.push(mij);
        }
        m.push(mi);
    }
    Constants {
        c,
        m,
        p: Vec::new(),
        s: Vec::new(),
        n_rounds_f: 8,
        n_rounds_p: vec![
            55, 55, 56, 56, 56, 56, 57, 57, 57, 57, 57, 57, 57, 57, 59, 59,
        ],
    }
}

pub struct Poseidon;

impl Default for Poseidon {
    fn default() -> Self {
        Self::new()
    }
}

impl Poseidon {
    pub fn new() -> Poseidon {
        Self {}
    }
    pub fn ark(&self, state: &mut Vec<Fr>, c: &[Fr], it: usize) {
        for i in 0..state.len() {
            state[i].add_assign(&c[it + i]);
        }
    }

    #[inline(always)]
    fn pow5(x: &mut Fr) {
        let aux = *x;
        x.square();
        x.square();
        x.mul_assign(&aux);
    }

    pub fn sbox(&self, n_rounds_f: usize, n_rounds_p: usize, state: &mut Vec<Fr>, i: usize) {
        if i < n_rounds_f / 2 || i >= n_rounds_f / 2 + n_rounds_p {
            for x in state {
                Self::pow5(x);
            }
        } else {
            Self::pow5(&mut state[0])
        }
    }

    pub fn mix(&self, state: &Vec<Fr>, m: &[Vec<Fr>]) -> Vec<Fr> {
        let mut new_state: Vec<Fr> = Vec::new();
        for i in 0..state.len() {
            new_state.push(Fr::zero());
            for (j, x) in state.iter().enumerate() {
                let mut mij = m[i][j];
                mij.mul_assign(x);
                new_state[i].add_assign(&mij);
            }
        }
        new_state
    }

    /// Hash function
    /// init_state would be Fr::zero() initially
    pub fn hash(&self, inp: &Vec<Fr>, init_state: &Fr) -> Result<Fr, String> {
        let result = self.hash_inner(inp, init_state, 2)?;
        Ok(result[1])
    }

    pub fn hash_ex(&self, inp: &Vec<Fr>, init_state: &Fr, out: usize) -> Result<Vec<Fr>, String> {
        self.hash_inner(inp, init_state, out)
    }

    fn hash_inner(&self, inp: &Vec<Fr>, init_state: &Fr, out: usize) -> Result<Vec<Fr>, String> {
        if inp.is_empty() || inp.len() > POSEIDON_BLS12381_CONSTANTS.n_rounds_p.len() {
            return Err(format!(
                "Wrong inputs length {} > {}",
                inp.len(),
                POSEIDON_BLS12381_CONSTANTS.n_rounds_p.len()
            ));
        }

        let t = inp.len() + 1;
        let n_rounds_f = POSEIDON_BLS12381_CONSTANTS.n_rounds_f;
        let n_rounds_p = POSEIDON_BLS12381_CONSTANTS.n_rounds_p[t - 2];

        let mut state = vec![init_state.clone(); t];
        state[1..].clone_from_slice(&inp);

        for i in 0..(n_rounds_f + n_rounds_p) {
            self.ark(&mut state, &POSEIDON_BLS12381_CONSTANTS.c[t - 2], i * t);
            self.sbox(n_rounds_f, n_rounds_p, &mut state, i);
            state = self.mix(&state, &POSEIDON_BLS12381_CONSTANTS.m[t - 2]);
        }
        Ok((&state[0..out]).to_vec())
    }
}

#[cfg(test)]
mod tests {
    use crate::field_bls12381::Fr;
    use crate::poseidon_bls12381::*;

    #[test]
    fn test_load_constants() {
        let cons = load_constants();
        assert_eq!(
            cons.c[0][0].to_string(),
            "Fr(0x525dd14d753a142ba9f083211a71385591c3aa1c56b69c6a35ffe039e9c9b72e)"
        );
        assert_eq!(
            cons.c[cons.c.len() - 1][0].to_string(),
            "Fr(0x110ba2bc11394ebdc472727c9683ed70624a37009ffed519b77bcea2c051b459)"
        );
        assert_eq!(
            cons.m[0][0][0].to_string(),
            "Fr(0x39f6d3a994cebea4199cec0404d0ec02a9ded2017fff2dff7fffffff80000001)"
        );
        assert_eq!(
            cons.m[cons.m.len() - 1][0][0].to_string(),
            "Fr(0x1b46fa31af7059b6a2a432d4b6f8e788c868db4bffff9d2cf0f0f0f0b4b4b4b5)"
        );
    }

    #[test]
    fn test_poseidon_hash() {
        let poseidon = Poseidon::new();

        let b0: Fr = Fr::from_str("0").unwrap();
        let b1: Fr = Fr::from_str("1").unwrap();
        let b2: Fr = Fr::from_str("2").unwrap();
        let b3: Fr = Fr::from_str("3").unwrap();
        let b4: Fr = Fr::from_str("4").unwrap();

        let is = Fr::zero();
        let h = poseidon.hash(&vec![b1], &is).unwrap();
        assert_eq!(
            h.to_string(),
            "Fr(0x164efff6c8a32ef98836c868f8c8dedcbe3068d16ba6098f282a6d185edb551f)"
        );

        let h = poseidon.hash(&vec![b1, b0], &is).unwrap();
        assert_eq!(
            h.to_string(),
            "Fr(0x59220c0fc5748e83c141c7bb8dae0a2bd5bbb227c778ede87296ba07960ec3d8)"
        );

        let h = poseidon.hash(&vec![b1, b0, b0], &is).unwrap();
        assert_eq!(
            h.to_string(),
            "Fr(0x73584296b068384db6028b55d995108518d4483ab177197274effe979b91526e)"
        );

        let h = poseidon.hash(&vec![b1, b2, b0, b0, b0], &is).unwrap();
        assert_eq!(
            h.to_string(),
            "Fr(0x385acd94e53a8c6f981809c2201582beceaec12250200f1e75ba93e6cf5ec736)"
        );

        let h = poseidon.hash(&vec![b1, b2, b0, b0, b0, b0], &is).unwrap();
        assert_eq!(
            h.to_string(),
            "Fr(0x023dd8aecc0967c0588754eebd39af39bdae2bbf4195fee1208613c909aaa29b)"
        );

        let h = poseidon.hash(&vec![b3, b4, b0, b0, b0], &is).unwrap();
        assert_eq!(
            h.to_string(),
            "Fr(0x19c96d726da9e3df4e5d0da19f324f7bf376dc7bf97efbf37082473f7fa24af8)"
        );

        let h = poseidon.hash(&vec![b3, b4, b0, b0, b0, b0], &is).unwrap();
        assert_eq!(
            h.to_string(),
            "Fr(0x0cb7b1761b9abe661847a10701c6eae7c631ff580c5b7f3ac2f8be1088d22bba)"
        );

        let h = poseidon.hash(&vec![b1, b2, b3, b4], &is).unwrap();
        assert_eq!(
            h.to_string(),
            "Fr(0x6f5f297b0ab0d1e7400501b9bdd4c3be2fe676b6a05deb845143b87355167a8d)"
        );
    }

    #[test]
    fn test_batch_hash() {
        let poseidon = Poseidon::new();

        let inputs: Vec<_> = (0..16).collect::<Vec<u64>>();
        let inp: Vec<Fr> = inputs
            .iter()
            .map(|e| Fr::from_str(&e.to_string()).unwrap())
            .collect();

        let is = Fr::zero();
        let h = poseidon.hash(&inp, &is).unwrap();
        assert_eq!(
            h.to_string(),
            "Fr(0x12d374bbdb8d3c1c0230b20b8fe1572f1e652a616d16e834718a982574106405)",
        );
    }
}
